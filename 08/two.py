# --- Advent of code 2021: Day 08 ---

# (File automatically generated by aocTool, developed by Bolu, 2020-2021.)

signals = open("input.txt").read().splitlines()
patterns = [line.split(" | ")[0].split(" ") for line in signals]
outputs = [line.split(" | ")[1].split(" ") for line in signals]

segments = [{ chr(ord('a') + i): "" for i in range(7) } for i in range(len(patterns))]
numbers = { "abcefg": 0, "cf": 1, "acdeg": 2, "acdfg": 3, "bcdf": 4, "abdfg": 5, "abdefg": 6, "acf": 7, "abcdefg": 8, "abcdfg": 9 }
results = [0 for i in range(len(patterns))]
transl8r = [None for i in range(10)]

for i in range(len(patterns)):
	# Init current variables
	pattern = patterns[i]
	segment = segments[i]

	# Unique digits:
	for pat in pattern:
		if len(pat) == 2:
			transl8r[1] = pat
		elif len(pat) == 3:
			transl8r[7] = pat
		elif len(pat) == 4:
			transl8r[4] = pat
		elif len(pat) == 7:
			transl8r[8] = pat

	# Possibilities for c and f (from 1)
	segment["c"] = transl8r[1]
	segment["f"] = transl8r[1]

	# a (from 7 - 1):
	for c in transl8r[7]:
		if c not in segment["c"] and c not in segment["f"]:
			segment["a"] = c

	# Possibilites for b and d (from 4 - 1)
	for c in transl8r[4]:
		if c not in segment["c"] and c not in segment["f"]:
			segment["b"] += c
			segment["d"] += c

	# Possibilites for e and g (from 8 - (7 + 4))
	for c in transl8r[8]:
		if c not in segment["a"] and c not in segment["b"] and c not in segment["c"] and c not in segment["d"] and c not in segment["f"]:
			segment["e"] += c
			segment["g"] += c

	# Non-unique digits

	# 6 segment digits:
	for pat in pattern:
		if len(pat) == 6:
			remaining_segment = ""
			for c in transl8r[8]:
				if c not in pat:
					remaining_segment = c

			# c and f (from 1 - (8 - 6)):
			if remaining_segment in segment["c"]:
				transl8r[6] = pat
				segment["c"] = remaining_segment
				segment["f"] = segment["f"][0] if segment["f"][1] == remaining_segment else segment["f"][1]
			# e and g (from (8 - 4) - (9 - 8)):
			elif remaining_segment not in segment["d"]:
				transl8r[9] = pat
				segment["e"] = remaining_segment
				segment["g"] = segment["g"][0] if segment["g"][1] == remaining_segment else segment["g"][1]
			# d and b (from 4 - (8 - 0)):
			else:
				transl8r[0] = pat
				segment["d"] = remaining_segment
				segment["b"] = segment["b"][0] if segment["b"][1] == remaining_segment else segment["b"][1]

	# Patterns for 5 segment digits
	for pat in pattern:
		if len(pat) == 5:
			if segment["b"] not in pat:
				if segment["f"] not in pat:
					transl8r[2] = pat
				else:
					transl8r[3] = pat
			else:
				transl8r[5] = pat

	# Reverse dictionary:
	translator = { segment[seg]: seg for seg in segment }

	# Translate output:
	for out in outputs[i]:
		number = ""
		for c in out:
			number += translator[c]
		sorted_number = sorted(number)
		number = "".join(sorted_number)

		results[i] = results[i] * 10 + numbers[number]

print(f"Sum of outputs: {sum(results)}")
assert sum(results) == 1063760
